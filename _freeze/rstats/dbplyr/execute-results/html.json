{
  "hash": "1c3a9b559ffee942b68b2b1c91a1a474",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"dbplyr\"\ndescription: \"si simple, si compliqu√©..\"\nauthor: Simon Coulombe\ndate: 2024-08-16\ncategories: [r, dbplyr]\nlang: fr\n---\n\n\nhelp\n\n\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncon <- DBI::dbConnect(RSQLite::SQLite(), dbname = \":memory:\")\n\ncopy_to(con, nycflights13::flights, \"flights\",\n  temporary = FALSE, \n  indexes = list(\n    c(\"year\", \"month\", \"day\"), \n    \"carrier\", \n    \"tailnum\",\n    \"dest\"\n  )\n)\n\ncopy_to(con, iris, \"iris\",\n  temporary = FALSE, \n  indexes = NULL\n)\n```\n:::\n\n\nlazy connect to the tables\n\n::: {.cell}\n\n```{.r .cell-code}\nflights_db <- tbl(con, \"flights\")\niris_db <- tbl(con, \"iris\")\n```\n:::\n\n\nif the table is in a schema, use dbplyr::in_schema:  \n# working with schema  \n\nTo write to a table in a schema, I can use DBI::Id() and dbplyr::in_schema(), like so:  \n\n::: {.cell}\n\n```{.r .cell-code}\nDBI::dbWriteTable(con, DBI::Id(schema = \"my_schema\",   table = \"iris\"),  value = iris, overwrite = TRUE)\niris_db <-  tbl(con,dbplyr::in_schema(\"my_schema\",\"iris\")) \n```\n:::\n\nnote that dbWriteTable is pretty slow, consider using the `bcp` tool when working with real database.\n\n# generate a cool sql query using dbplyr and across\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_query <- iris_db %>% \n  summarise(\n    across(.cols = starts_with((\"Sepal\")),\n           .fns = list(mean = mean, min = min)\n           )\n    )\n\nmy_query %>% show_query()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<SQL>\nSELECT\n  AVG(`Sepal.Length`) AS `Sepal.Length_mean`,\n  MIN(`Sepal.Length`) AS `Sepal.Length_min`,\n  AVG(`Sepal.Width`) AS `Sepal.Width_mean`,\n  MIN(`Sepal.Width`) AS `Sepal.Width_min`\nFROM `iris`\n```\n\n\n:::\n:::\n\n\ndownload the result from my query\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_query %>% collect()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 x 4\n  Sepal.Length_mean Sepal.Length_min Sepal.Width_mean Sepal.Width_min\n              <dbl>            <dbl>            <dbl>           <dbl>\n1              5.84              4.3             3.06               2\n```\n\n\n:::\n:::\n\nremotely execute the query using dplyr::compute()  and save under a new name in the db.  Normally I would set \"temporary = FALSE\", but it doesnt work with rsqlite.\n\nThis is useful when I want to use dbplyr to generate SQL code (like using across above), but I want the processing to be done by the SQL server.  No bandwidth or CPU would be used in this case.  \n\n::: {.cell}\n\n```{.r .cell-code}\n#compute(my_query, \"my_query_output\", temporary = FALSE)\ncompute(my_query, \"my_query_output\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# Source:   table<`my_query_output`> [1 x 4]\n# Database: sqlite 3.45.2 [:memory:]\n  Sepal.Length_mean Sepal.Length_min Sepal.Width_mean Sepal.Width_min\n              <dbl>            <dbl>            <dbl>           <dbl>\n1              5.84              4.3             3.06               2\n```\n\n\n:::\n\n```{.r .cell-code}\nmy_query_output_db <- tbl(con, \"my_query_output\")\nmy_query_output_db\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# Source:   table<`my_query_output`> [1 x 4]\n# Database: sqlite 3.45.2 [:memory:]\n  Sepal.Length_mean Sepal.Length_min Sepal.Width_mean Sepal.Width_min\n              <dbl>            <dbl>            <dbl>           <dbl>\n1              5.84              4.3             3.06               2\n```\n\n\n:::\n:::\n\n\n# some notes on SQL translation     \n\n  * nrow() doesnt work, use tally().  \n  * unique() doesnt work, use distinct()  \n  * ifelse() doesnt work, use case_when()  \n  * left_join does work well with join_by()  :   \n    `left_join(table_b, join_by(key_a ==  key_b)) `\n  \n# Azure Synapse specific stuff    \n\n## How to list tables in a specific schema   \n\n`\ntables_available <- dbGetQuery(con,\n           \"SELECT table_name FROM information_schema.tables\n                   WHERE table_schema='my_schema'\")\n`\n\n## How to rename a table   \n`\nrename object my_schema.test  to test_bak ;    \n`\n\n## Dont forget to use distribution.... \n\n`\ncreate table my_schema.my_sample \nwith (distribution = round_robin ) as select  top 100 * from my_schema.my_full_table\n`\n\n## Insert rows    \n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}