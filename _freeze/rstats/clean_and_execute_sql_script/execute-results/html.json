{
  "hash": "be391f01bde55e3f473d6f9c79dd4fea",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Executing an SQL script from R after injecting some values from R in that script\"\nauthor: Simon Coulombe\ndescription: |\n  Invalid object name...\ndate: 2024-09-12\nformat:\n  html:\n    code-fold: false\n---\n\n\nChallenge: I have an old SQL script that I want to run.  I also want to edit a part of that script using a value provided by R.  \n\nLet's say this is my full script that we will want to run.  \nAll it does is create a table called \"prout\" out of thin air, then  creates a new table \"prout2\" from that first table.  \nWe will also want to replace the final table name 'prout2' with some variable.  \n\n::: {.cell}\n\n```{.r .cell-code}\nscript <- \"\n\n/* this query has \nintentionally messy \ncomments\n*/\ncreate table prout as \n  Select \n    2 as COL_A -- with a comment here\n\n  ;\n-- or wherever\n\n/* and some more commen ts here */\n\ncreate table prout2  as \n    Select \n    * -- with a comment here\n\n    FROM \n      -- and some helpful comment here\n      prout\n    ;\n    -- or wherever\n\n\"    \n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\nlibrary(dbplyr)\nlibrary(DBI)\nlibrary(\"RSQLite\")\ncon <- DBI::dbConnect(RSQLite::SQLite(), dbname = \":memory:\")\n```\n:::\n\n\n\n# Step 1  - cleaning the script    \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# pass in either a text query or path to a sql file\nclean_script <- function( text_or_path = '//example/path/to/some_query.sql' , echo = FALSE){\n  # modified from Tori Oblad's script https://stackoverflow.com/a/58446028/5657234\n  # if sql path, read, otherwise assume text input\n  if( stringr::str_detect(text_or_path, \"(?i)\\\\.sql$\") ){\n    text_or_path <- text_or_path %>% read_lines() %>% stringr::str_c(sep = \" \", collapse = \"\\n\")\n  }\n  \n  \n  # echo original query to the console \n  #  (unnecessary, but helpful for status if passing sequential queries to a db)\n  if(echo){cat(\"\\nThe query you're processing is: \\n\", text_or_path, \"\\n\\n\")}\n  \n  \n  # remove comments \n  clean_script <- text_or_path %>% \n    # remove all demarked /*  */ sql comments \n    gsub(pattern = '/\\\\*.*?\\\\*/', replacement = ' ') %>% \n    # remove all demarked -- comments \n    gsub(pattern = '--[^\\r\\n]*', replacement = ' ') %>% \n    #remove any line break, tab, etc.\n    gsub(pattern = '[\\r\\n\\t\\f\\v]', replacement = ' ') %>%  \n    # remove extra whitespace \n    gsub(pattern = ' +', replacement = ' ') \n\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncleaned_script <- clean_script(script)\ncleaned_script\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \" create table prout as Select 2 as COL_A ; create table prout2 as Select * FROM prout ; \"\n```\n\n\n:::\n:::\n\nlet's try and execute it \n\n::: {.cell}\n\n```{.r .cell-code}\ndbExecute(con, cleaned_script)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0\n```\n\n\n:::\n:::\n\nHere we get a warning that is pretty clear \"Ignoring remaining part of query: create table prout2 Select * FROM prout ; \".  This means the 2nd part of the script won'T be executed.  \n\nAt work, SQL Server  just tries to run all queries in parallel and will return \"Invalid Object Name: prout\" because the second script tries to read from a table the first script hasnt created yet.  \n\n# Step 2: split the script into multiple queries and execute them  \nThe quick fix is to split the queries and execute them one at a time:   \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndbRemoveTable(con, \"prout\")\n\n\nsplit_script <- function(script){\n  unlist(strsplit(script, \"\\\\s*;\\\\s*\"))\n}\n\nqueries <-split_script(cleaned_script)\n\n\nexecute_queries <- function(con, queries){\n  for (query in queries){\n    message(\"executing query- \", query)\n    dbExecute(con, query)\n  }\n}\n\nexecute_queries(con, queries)\n```\n:::\n\nAwesome!  \n\n# Step 3 -  edit the SQL script from R to inject some values   \n\n\nNow let's say that I want the output of the final output table name  to be editable by R.  This is where glue_sql() comes in and it is pretty neat.   \n\nFirst, we modify the original script to replace 'prout2'  with {output_table_name}.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nscript_with_editable_table_name <- \"\n\n/* this query has \nintentionally messy \ncomments\n*/\ncreate table prout as \n  Select \n    2 as COL_A -- with a comment here\n\n  ;\n-- or wherever\n\n/* and some more commen ts here */\n\ncreate table {output_table_name}  as \n    Select \n    * -- with a comment here\n\n    FROM \n      -- and some helpful comment here\n      prout\n    ;\n    -- or wherever\n\n\"    \n```\n:::\n\n\nThen we clean the query, and we apply the glue_sql function to all queries:  \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndbRemoveTable(con, \"prout\")\ndbRemoveTable(con, \"prout2\")\noutput_table_name <- \"new_table_name\"\ncleaned_script <- clean_script(script_with_editable_table_name)\nqueries <-  split_script(cleaned_script)\nupdated_queries <- purrr::map(queries, ~ .x %>%  glue::glue_sql(.con = con))\nexecute_queries(con, updated_queries)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndbGetQuery(con, \"select * from new_table_name\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  COL_A\n1     2\n```\n\n\n:::\n:::\n\n\n\nWoohoo!\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}